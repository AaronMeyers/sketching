// Generated by CoffeeScript 1.6.3
var MoireCone, Scene,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

MoireCone = (function() {
  function MoireCone(options) {
    if (options == null) {
      options = {};
    }
    this.angle = options.angle != null ? options.angle : 50;
    this.numLines = options.numLines != null ? options.numLines : 20;
    this.radius = options.radius != null ? options.radius : 400;
    this.lineManager = new LineManager({
      maxLines: this.numLines
    });
    this.mesh = this.lineManager.mesh;
    this.position = this.mesh.position;
    this.rotation = this.mesh.rotation;
    this.homeX = options.homeX != null ? options.homeX : 0;
    this.position.x = this.homeX;
    this.makeLines();
  }

  MoireCone.prototype.makeLines = function() {
    var angle, i, _i, _ref;
    this.lineManager.clear();
    for (i = _i = 1, _ref = this.numLines; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      angle = utils.map(i, 1, this.numLines, -this.angle / 2, this.angle / 2);
      angle *= Math.PI / 180;
      this.lineManager.addLine(0, 0, Math.sin(angle) * this.radius, Math.cos(angle) * this.radius);
      if (i === 1) {
        this.extent = (500 / Math.cos(angle)) * Math.sin(angle);
      }
    }
    return this.lineManager.update();
  };

  MoireCone.prototype.setAngle = function(angle) {
    this.angle = angle;
    return this.makeLines();
  };

  return MoireCone;

})();

Scene = (function() {
  function Scene(options) {
    this.update = __bind(this.update, this);
    this.WIDTH = options.width !== void 0 ? options.width : 500;
    this.HEIGHT = options.height !== void 0 ? options.height : 500;
    this.renderer = new THREE.WebGLRenderer({
      preserveDrawingBuffer: true,
      antialias: true
    });
    this.renderer.setSize(options.width, options.height);
    $('#container').append(this.renderer.domElement);
    this.scene = new THREE.Scene();
    this.camera = new THREE.OrthographicCamera(this.WIDTH / -2, this.WIDTH / 2, this.HEIGHT, 0, -5000, 5000);
    this.frameLength = 1000 / 30;
    this.time = 0;
    this.frames = [];
    this.saveFrames = false;
  }

  Scene.prototype.init = function() {
    var coneL, coneR, i, _i, _ref;
    this.bigAngle = 28;
    this.smallAngle = 15;
    this.angle = this.bigAngle;
    this.cone = new MoireCone({
      radius: this.HEIGHT + 100,
      angle: this.angle
    });
    this.scene.add(this.cone.mesh);
    this.sideCones = [];
    this.conesPerSide = 15;
    for (i = _i = 1, _ref = this.conesPerSide; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      coneL = new MoireCone({
        angle: this.angle,
        radius: this.HEIGHT + 100,
        homeX: this.cone.extent * i
      });
      coneR = new MoireCone({
        angle: this.angle,
        radius: this.HEIGHT + 100,
        homeX: this.cone.extent * -i
      });
      this.scene.add(coneL.mesh);
      this.scene.add(coneR.mesh);
      if (i % 2 === 1) {
        coneL.position.y = coneR.position.y = this.HEIGHT;
        coneL.rotation.z = coneR.rotation.z = Math.PI;
      }
      this.sideCones.push(coneL, coneR);
    }
    this.tweenToAngle(this.smallAngle);
    return this.update();
  };

  Scene.prototype.tweenToAngle = function(angle) {
    var tween;
    tween = new TWEEN.Tween(this);
    tween.to({
      angle: angle
    }, 2000);
    tween.easing(TWEEN.Easing.Sinusoidal.InOut);
    tween.onUpdate(function() {
      var i, _i, _ref, _results;
      this.cone.setAngle(this.angle);
      _results = [];
      for (i = _i = 1, _ref = this.conesPerSide; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        this.sideCones[(i - 1) * 2 + 0].setAngle(this.angle);
        this.sideCones[(i - 1) * 2 + 0].position.x = i * this.cone.extent;
        this.sideCones[(i - 1) * 2 + 1].setAngle(this.angle);
        _results.push(this.sideCones[(i - 1) * 2 + 1].position.x = -i * this.cone.extent);
      }
      return _results;
    });
    tween.onComplete(function() {
      return this.tweenToAngle(this.angle === this.bigAngle ? this.smallAngle : this.bigAngle);
    });
    return tween.start(this.time);
  };

  Scene.prototype.update = function() {
    var frame,
      _this = this;
    setTimeout((function() {
      return requestAnimationFrame(_this.update);
    }), this.frameLength);
    TWEEN.update(this.time);
    this.time += this.frameLength;
    this.renderer.render(this.scene, this.camera);
    if (this.saveFrames) {
      frame = this.renderer.domElement.toDataURL.replace(/^data:image\/(png|jpg);base64,/, "");
      return this.frames.push(frame);
    }
  };

  return Scene;

})();
