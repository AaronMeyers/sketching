// Generated by CoffeeScript 1.6.3
var Scene,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Scene = (function() {
  function Scene(options) {
    this.update = __bind(this.update, this);
    var i,
      _this = this;
    this.WIDTH = options.width !== void 0 ? options.width : 500;
    this.HEIGHT = options.height !== void 0 ? options.height : 500;
    this.renderer = new THREE.WebGLRenderer({
      preserveDrawingBuffer: true,
      antialias: true
    });
    this.renderer.setSize(options.width, options.height);
    $('#container').append(this.renderer.domElement);
    this.scene = new THREE.Scene();
    this.camera = new THREE.OrthographicCamera(this.WIDTH / -2, this.WIDTH / 2, this.HEIGHT / 2, this.HEIGHT / -2, -5000, 5000);
    this.frameLength = 1000 / 30;
    this.time = 0;
    this.frames = [];
    this.saveFrames = true;
    this.gui = new dat.GUI({
      height: 1000,
      width: 300
    });
    this.rotationAmount = 1;
    this.gui.add(this, 'rotationAmount', -4, 4).step(.05);
    this.startingLevel = 0;
    this.numLevels = 4;
    this.allCircles = [];
    i = 0;
    while (i < this.numLevels) {
      this.allCircles[i] = [];
      i++;
    }
    this.cameraTarget = new THREE.Vector3;
    this.cameraTargetStart = new THREE.Vector3;
    this.cameraTargetLerp = 0;
    this.cameraWidth = this.WIDTH;
    this.targetCircle = null;
    this.circleRotationStart = 0;
    this.circleRotationEnd = 0;
    $('#container').on('mousedown', function(e) {
      _this.reset();
      return _this.animateIntoCircle(_this.allCircles[_this.startingLevel + 1][0]);
    });
  }

  Scene.prototype.init = function() {
    var circleGeom, circleMaterial;
    circleGeom = new THREE.CircleGeometry(this.WIDTH / 2, 100);
    circleMaterial = new THREE.MeshBasicMaterial({
      color: 0xFFFFFF,
      wireframe: false
    });
    this.circle = new THREE.Mesh(circleGeom, circleMaterial);
    this.createCirclesInCircle(this.circle);
    this.scene.add(this.circle);
    this.whiteShield = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshBasicMaterial({
      transparent: true,
      color: 0xFFFFFF
    }));
    this.blackShield = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshBasicMaterial({
      transparent: true,
      color: 0x000000
    }));
    this.scene.add(this.whiteShield);
    this.scene.add(this.blackShield);
    this.scene.updateMatrixWorld();
    this.reset();
    return this.update();
  };

  Scene.prototype.reset = function() {
    var c, i, j, _i, _len, _ref;
    this.targetCircle = this.allCircles[this.startingLevel][0];
    this.cameraTarget = this.getWorldPosition(this.targetCircle);
    this.cameraWidth = this.targetCircle.geometry.radius * 2;
    this.currentShield = this.startingLevel % 2 === 0 ? this.whiteShield : this.blackShield;
    this.targetCircle.add(this.currentShield);
    this.currentShield.position.z = -.01;
    this.targetCircle.position.z = .1;
    i = 0;
    while (i < this.allCircles.length) {
      _ref = this.allCircles[i];
      for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
        c = _ref[j];
        c.rotation.z = 0;
        c.material.opacity = i > this.startingLevel + 1 ? 0 : 1;
      }
      i++;
    }
    return this.animateIntoCircle(this.allCircles[this.startingLevel + 1][0]);
  };

  Scene.prototype.animateIntoCircle = function(theCircle) {
    var tween,
      _this = this;
    this.targetCircle = theCircle;
    this.cameraTargetStart.set(this.cameraTarget.x, this.cameraTarget.y, this.cameraTarget.z);
    this.cameraTargetLerp = 0;
    this.circleRotationStart = this.targetCircle.rotation.z;
    this.circleRotationEnd = this.circleRotationStart - Math.PI * this.rotationAmount;
    this.currentShield = (theCircle.level % 2 === 1 ? this.blackShield : this.whiteShield);
    this.targetCircle.add(this.currentShield);
    this.currentShield.material.opacity = 0;
    this.currentShield.position.z = -.01;
    this.targetCircle.position.z = .1;
    tween = new TWEEN.Tween(this);
    tween.to({
      cameraWidth: this.targetCircle.geometry.radius * 2,
      cameraTargetLerp: 1
    }, 1000);
    tween.easing(TWEEN.Easing.Quadratic.InOut);
    tween.onUpdate(function() {
      var c, i, worldPos, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      _ref = _this.allCircles[_this.targetCircle.level - 1];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        c = _ref[i];
        c.rotation.z = utils.lerp(_this.circleRotationStart, _this.circleRotationEnd, _this.cameraTargetLerp);
      }
      worldPos = new THREE.Vector3;
      _this.targetCircle.parent.parent.updateMatrixWorld();
      worldPos.getPositionFromMatrix(_this.targetCircle.matrixWorld);
      worldPos.lerp(_this.cameraTargetStart, 1.0 - _this.cameraTargetLerp);
      _this.cameraTarget = worldPos.clone();
      _this.currentShield.material.opacity = _this.cameraTargetLerp;
      _ref1 = _this.allCircles[_this.targetCircle.level];
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        c = _ref1[i];
        c.rotation.z = Math.PI * 4 / 3 * _this.cameraTargetLerp;
      }
      _ref2 = _this.allCircles[_this.targetCircle.level + 1];
      _results = [];
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        c = _ref2[i];
        _results.push(c.material.opacity = _this.cameraTargetLerp);
      }
      return _results;
    });
    tween.onComplete(function() {
      if (_this.targetCircle.level + 2 < _this.numLevels) {
        return _this.animateIntoCircle(_this.allCircles[_this.targetCircle.level + 1][0]);
      } else {
        if (_this.saveFrames) {
          _this.saveFrames = false;
          _this.saveFramesToZip();
          $('#download').fadeIn();
        }
        return _this.reset();
      }
    });
    return tween.start(this.time);
  };

  Scene.prototype.createCirclesInCircle = function(theCircle, level) {
    var aCircle, aCircleGeom, aCircleMaterial, aNode, color, i, numCircles, opacity, _results;
    if (level == null) {
      level = 0;
    }
    i = 0;
    numCircles = 3;
    _results = [];
    while (i < numCircles) {
      color = level % 2 === 1 ? 0xFFFFFF : 0x000000;
      opacity = level > this.startingLevel + 1 ? 0 : 1;
      aCircleGeom = new THREE.CircleGeometry(theCircle.geometry.radius / (1 + (2 / 3) * Math.sqrt(3)), 60);
      aCircleMaterial = new THREE.MeshBasicMaterial({
        color: color,
        wireframe: false,
        transparent: true,
        opacity: opacity
      });
      aNode = new THREE.Object3D;
      aCircle = new THREE.Mesh(aCircleGeom, aCircleMaterial);
      aCircle.position.z = .01;
      aCircle.position.x = theCircle.geometry.radius - aCircle.geometry.radius;
      aNode.rotation.z = (i / numCircles) * Math.PI * 2;
      aNode.add(aCircle);
      theCircle.add(aNode);
      aCircle.level = level;
      this.allCircles[level].push(aCircle);
      if (level + 1 < this.numLevels) {
        this.createCirclesInCircle(aCircle, level + 1);
      }
      _results.push(i++);
    }
    return _results;
  };

  Scene.prototype.getWorldPosition = function(node) {
    var vector;
    vector = new THREE.Vector3;
    node.updateMatrixWorld();
    vector.getPositionFromMatrix(node.matrixWorld);
    return vector;
  };

  Scene.prototype.saveFramesToZip = function() {
    var blobLink, folder, i, pad, zip;
    pad = function(n, width, z) {
      z = z || '0';
      n = n + '';
      if (n.length >= width) {
        return n;
      } else {
        return new Array(width - n.length + 1).join(z) + n;
      }
    };
    zip = new JSZip();
    folder = zip.folder("frames");
    i = 0;
    while (i < this.frames.length) {
      folder.file("frame" + pad(i, 3, 0) + ".png", this.frames[i], {
        base64: true
      });
      i++;
    }
    blobLink = document.getElementById('download');
    blobLink.download = "frames.zip";
    return blobLink.href = window.URL.createObjectURL(zip.generate({
      type: "blob"
    }));
  };

  Scene.prototype.update = function() {
    var frame, worldPos,
      _this = this;
    setTimeout((function() {
      return requestAnimationFrame(_this.update);
    }), this.frameLength);
    TWEEN.update(this.time);
    this.time += this.frameLength;
    this.circle.children[0].updateMatrixWorld();
    worldPos = new THREE.Vector3;
    worldPos.getPositionFromMatrix(this.circle.children[0].children[0].matrixWorld);
    this.camera.left = this.cameraTarget.x - this.cameraWidth / 2;
    this.camera.right = this.cameraTarget.x + this.cameraWidth / 2;
    this.camera.top = this.cameraTarget.y + this.cameraWidth / 2;
    this.camera.bottom = this.cameraTarget.y - this.cameraWidth / 2;
    this.camera.updateProjectionMatrix();
    this.renderer.render(this.scene, this.camera);
    if (this.saveFrames) {
      frame = this.renderer.domElement.toDataURL().replace(/^data:image\/(png|jpg);base64,/, "");
      return this.frames.push(frame);
    }
  };

  return Scene;

})();
