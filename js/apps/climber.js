// Generated by CoffeeScript 1.6.3
var Scene,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Scene = (function() {
  function Scene(options) {
    this.update = __bind(this.update, this);
    var edgeEffect, effect, effectFXAA, renderTargetParams;
    this.WIDTH = options.width !== void 0 ? options.width : 500;
    this.HEIGHT = options.height !== void 0 ? options.height : 500;
    this.renderer = new THREE.WebGLRenderer({
      preserveDrawingBuffer: true,
      antialias: true
    });
    this.renderer.setSize(options.width, options.height);
    $('#container').append(this.renderer.domElement);
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(60, this.WIDTH / this.HEIGHT, .1, 1000);
    renderTargetParams = {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBFormat,
      stencilBuffer: false
    };
    this.composer = new THREE.EffectComposer(this.renderer, new THREE.WebGLRenderTarget(this.WIDTH, this.HEIGHT, renderTargetParams));
    this.composer.addPass(new THREE.RenderPass(this.scene, this.camera));
    edgeEffect = new THREE.ShaderPass(THREE.EdgeShader2);
    edgeEffect.uniforms['aspect'].value.x = this.WIDTH;
    edgeEffect.uniforms['aspect'].value.y = this.HEIGHT;
    this.ssaoEffect = new THREE.ShaderPass(THREE.SSAOShader);
    this.ssaoEffect.uniforms['size'].value.set(this.WIDTH, this.HEIGHT);
    effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
    effectFXAA.uniforms['resolution'].value.set(1 / this.WIDTH, 1 / this.HEIGHT);
    this.composer.addPass(effectFXAA);
    effect = new THREE.ShaderPass(THREE.CopyShader);
    effect.renderToScreen = true;
    this.composer.addPass(effect);
    this.frameLength = 1000 / 30;
    this.time = 0;
    this.frames = [];
    this.saveFrames = true;
  }

  Scene.prototype.init = function() {
    var cube, i, numCubes, _i;
    this.animate = true;
    this.cameraStartY = 100;
    this.camera.position.set(0, this.cameraStartY, 100);
    this.camera.lookAt(new THREE.Vector3(0, 200, 0));
    this.light = new THREE.PointLight(0xFFFFFF, 1.5, 200);
    this.scene.add(this.light);
    this.cubeStride = 10;
    this.totalSeconds = 1.5;
    this.cubes = [];
    this.root = new THREE.Object3D;
    this.root.rotation.y = Math.PI / 4;
    this.scene.add(this.root);
    numCubes = 50;
    for (i = _i = 1; 1 <= numCubes ? _i <= numCubes : _i >= numCubes; i = 1 <= numCubes ? ++_i : --_i) {
      cube = new THREE.Mesh(new THREE.CubeGeometry(10000, this.cubeStride, this.cubeStride), new THREE.MeshPhongMaterial);
      cube.rotation.y = i % 2 === 0 ? Math.PI / 2 : 0;
      cube.position.y = i * 10;
      this.root.add(cube);
      this.cubes.push(cube);
    }
    this.spinStack(this.totalSeconds * 1000);
    return this.update();
  };

  Scene.prototype.spinStack = function(totalTime) {
    var delay, i, lastStart, numToSpin, spinLength, _i, _ref, _results;
    numToSpin = 26;
    spinLength = totalTime / 3;
    lastStart = totalTime - spinLength;
    _results = [];
    for (i = _i = 0, _ref = numToSpin - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      delay = utils.map(i, 0, numToSpin - 1, 0, lastStart);
      _results.push(this.spinCube(this.cubes[i + 10], spinLength, delay));
    }
    return _results;
  };

  Scene.prototype.spinCube = function(cube, time, delay) {
    var tween;
    if (time == null) {
      time = 500;
    }
    if (delay == null) {
      delay = 0;
    }
    tween = new TWEEN.Tween({
      cube: cube,
      rotationY: cube.rotation.y
    });
    tween.to({
      rotationY: cube.rotation.y + Math.PI / 2
    }, time);
    tween.easing(TWEEN.Easing.Quadratic.InOut);
    tween.delay(delay);
    tween.onUpdate(function() {
      return this.cube.rotation.y = this.rotationY;
    });
    return tween.start(this.time);
  };

  Scene.prototype.saveFramesToZip = function() {
    var blobLink, folder, i, pad, zip;
    pad = function(n, width, z) {
      z = z || '0';
      n = n + '';
      if (n.length >= width) {
        return n;
      } else {
        return new Array(width - n.length + 1).join(z) + n;
      }
    };
    zip = new JSZip();
    folder = zip.folder("frames");
    i = 0;
    while (i < this.frames.length) {
      folder.file("frame" + pad(i, 3, 0) + ".png", this.frames[i], {
        base64: true
      });
      i++;
    }
    blobLink = document.getElementById('download');
    blobLink.download = "frames.zip";
    return blobLink.href = window.URL.createObjectURL(zip.generate({
      type: "blob"
    }));
  };

  Scene.prototype.update = function() {
    var c, frame, i, _i, _len, _ref,
      _this = this;
    setTimeout((function() {
      return requestAnimationFrame(_this.update);
    }), this.frameLength);
    TWEEN.update(this.time);
    this.time += this.frameLength;
    this.camera.position.y += this.cubeStride / (this.frameLength * this.totalSeconds);
    if (this.camera.position.y >= this.cameraStartY + this.cubeStride) {
      this.camera.position.y = this.cameraStartY;
      _ref = this.cubes;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        c = _ref[i];
        c.rotation.y -= Math.PI / 2;
      }
      this.spinStack(this.totalSeconds * 1000);
      if (this.saveFrames) {
        this.saveFrames = false;
        this.saveFramesToZip();
        $('#download').fadeIn();
      }
    }
    this.light.position.set(this.camera.position.x, this.camera.position.y + 100, this.camera.position.z + 50);
    this.renderer.render(this.scene, this.camera);
    this.composer.render();
    if (this.saveFrames) {
      frame = this.renderer.domElement.toDataURL().replace(/^data:image\/(png|jpg);base64,/, "");
      return this.frames.push(frame);
    }
  };

  return Scene;

})();
