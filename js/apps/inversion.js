// Generated by CoffeeScript 1.6.3
var Scene,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Scene = (function() {
  function Scene(options) {
    this.update = __bind(this.update, this);
    this.WIDTH = options.width !== void 0 ? options.width : 500;
    this.HEIGHT = options.height !== void 0 ? options.height : 500;
    this.renderer = new THREE.WebGLRenderer({
      preserveDrawingBuffer: true,
      antialias: true
    });
    this.renderer.setSize(options.width, options.height);
    $('#container').append(this.renderer.domElement);
    this.scene = new THREE.Scene();
    this.camera = new THREE.OrthographicCamera(this.WIDTH / -2, this.WIDTH / 2, this.HEIGHT / 2, this.HEIGHT / -2, -5000, 5000);
    this.frameLength = 1000 / 30;
    this.time = 0;
    this.frames = [];
    this.saveFrames = true;
  }

  Scene.prototype.makeWheel = function(width, numCircles) {
    var circle, circleWidth, color, i, node, _i;
    node = new THREE.Object3D;
    for (i = _i = 1; 1 <= numCircles ? _i <= numCircles : _i >= numCircles; i = 1 <= numCircles ? ++_i : --_i) {
      circleWidth = utils.map(i, 1, numCircles + 1, width, 0);
      color = i % 2 === 0 ? 0x000000 : 0xFFFFFF;
      circle = new THREE.Mesh(new THREE.CircleGeometry(circleWidth / 2, 100), new THREE.MeshBasicMaterial({
        color: color
      }));
      circle.position.z = i * .01;
      node.add(circle);
    }
    return node;
  };

  Scene.prototype.makeBox = function(width, numBoxes) {
    var box, boxWidth, color, i, node, _i;
    node = new THREE.Object3D;
    for (i = _i = 1; 1 <= numBoxes ? _i <= numBoxes : _i >= numBoxes; i = 1 <= numBoxes ? ++_i : --_i) {
      boxWidth = utils.map(i, 1, numBoxes + 1, width, 0);
      color = i % 2 === 0 ? 0x000000 : 0xFFFFFF;
      box = new THREE.Mesh(new THREE.PlaneGeometry(boxWidth, boxWidth), new THREE.MeshBasicMaterial({
        color: color
      }));
      box.position.z = i * .01;
      node.add(box);
    }
    return node;
  };

  Scene.prototype.tweenNodePos = function(node, pos, time) {
    var tween;
    tween = new TWEEN.Tween({
      node: node,
      posX: node.position.x,
      posY: node.position.y,
      posZ: node.position.z
    });
    tween.to({
      posX: pos.x,
      posY: pos.y,
      posZ: pos.z
    }, time);
    tween.easing(TWEEN.Easing.Sinusoidal.InOut);
    tween.onUpdate(function() {
      return this.node.position.set(this.posX, this.posY, this.posZ);
    });
    tween.repeat(1000);
    tween.yoyo(true);
    return tween.start(this.time);
  };

  Scene.prototype.init = function() {
    this.wheelL = this.makeWheel(this.WIDTH, 10);
    this.wheelR = this.makeWheel(this.WIDTH, 10);
    this.renderTextureL = new THREE.WebGLRenderTarget(this.WIDTH, this.HEIGHT, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat
    });
    this.renderTextureR = new THREE.WebGLRenderTarget(this.WIDTH, this.HEIGHT, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat
    });
    this.sceneL = new THREE.Scene;
    this.sceneR = new THREE.Scene;
    this.sceneL.add(this.wheelL);
    this.sceneR.add(this.wheelR);
    this.wheelL.position.x = -this.WIDTH / 2;
    this.wheelR.position.x = this.WIDTH / 2;
    this.shaderMaterial = new THREE.ShaderMaterial(THREE.InvertShader);
    this.shaderMaterial.uniforms.tDiffuse1.value = this.renderTextureL;
    this.shaderMaterial.uniforms.tDiffuse2.value = this.renderTextureR;
    this.plane = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), this.shaderMaterial);
    this.scene.add(this.plane);
    this.animationLength = 2400;
    this.tweenNodePos(this.wheelL, new THREE.Vector3(this.WIDTH / 2, 0, 0), this.animationLength);
    this.tweenNodePos(this.wheelR, new THREE.Vector3(-this.WIDTH / 2, 0, 0), this.animationLength);
    return this.update();
  };

  Scene.prototype.update = function() {
    var frame,
      _this = this;
    setTimeout((function() {
      return requestAnimationFrame(_this.update);
    }), this.frameLength);
    TWEEN.update(this.time);
    this.time += this.frameLength;
    this.renderer.render(this.sceneL, this.camera, this.renderTextureL, true);
    this.renderer.render(this.sceneR, this.camera, this.renderTextureR, true);
    this.renderer.render(this.scene, this.camera);
    if (this.saveFrames) {
      frame = this.renderer.domElement.toDataURL().replace(/^data:image\/(png|jpg);base64,/, "");
      this.frames.push(frame);
      if (this.time >= this.animationLength) {
        this.saveFramesToZip();
        this.saveFrames = false;
        return $('#download').fadeIn();
      }
    }
  };

  Scene.prototype.saveFramesToZip = function() {
    var blobLink, folder, i, pad, zip;
    pad = function(n, width, z) {
      z = z || '0';
      n = n + '';
      if (n.length >= width) {
        return n;
      } else {
        return new Array(width - n.length + 1).join(z) + n;
      }
    };
    zip = new JSZip();
    folder = zip.folder("frames");
    i = 0;
    while (i < this.frames.length) {
      folder.file("frame" + pad(i, 3, 0) + ".png", this.frames[i], {
        base64: true
      });
      i++;
    }
    blobLink = document.getElementById('download');
    blobLink.download = "frames.zip";
    return blobLink.href = window.URL.createObjectURL(zip.generate({
      type: "blob"
    }));
  };

  return Scene;

})();
